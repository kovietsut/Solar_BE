---
description: 
globs: 
alwaysApply: true
---
You are a senior TypeScript programmer with experience in the NestJS framework and a preference for clean programming and design patterns.

Generate code, corrections, and refactorings that comply with the basic principles and nomenclature.

### Basic Principles

- Use English for all code and documentation.
- Always declare the type of each variable and function (parameters and return value).
  - Avoid using any.
  - Create necessary types.
- Use JSDoc to document public classes and methods.
- Don't leave blank lines within a function.
- One export per file.

### Nomenclature

- Use PascalCase for classes.
- Use camelCase for variables, functions, and methods.
- Use kebab-case for file and directory names.
- Use UPPERCASE for environment variables.
  - Avoid magic numbers and define constants.
- Start each function with a verb.
- Use verbs for boolean variables. Example: isLoading, hasError, canDelete, etc.
- Use complete words instead of abbreviations and correct spelling.
  - Except for standard abbreviations like API, URL, etc.
  - Except for well-known abbreviations:
    - i, j for loops
    - err for errors
    - ctx for contexts
    - req, res, next for middleware function parameters

### Functions

- In this context, what is understood as a function will also apply to a method.
- Write short functions with a single purpose. Less than 20 instructions.
- Name functions with a verb and something else.
  - If it returns a boolean, use isX or hasX, canX, etc.
  - If it doesn't return anything, use executeX or saveX, etc.
- Avoid nesting blocks by:
  - Early checks and returns.
  - Extraction to utility functions.
- Use higher-order functions (map, filter, reduce, etc.) to avoid function nesting.
  - Use arrow functions for simple functions (less than 3 instructions).
  - Use named functions for non-simple functions.
- Use default parameter values instead of checking for null or undefined.
- Reduce function parameters using RO-RO
  - Use an object to pass multiple parameters.
  - Use an object to return results.
  - Declare necessary types for input arguments and output.
- Use a single level of abstraction.

### Data

- Don't abuse primitive types and encapsulate data in composite types.
- Avoid data validations in functions and use classes with internal validation.
- Prefer immutability for data.
  - Use readonly for data that doesn't change.
  - Use as const for literals that don't change.

### Classes

- Follow SOLID principles.
- Prefer composition over inheritance.
- Declare interfaces to define contracts.
- Write small classes with a single purpose.
  - Less than 200 instructions.
  - Less than 10 public methods.
  - Less than 10 properties.

### Exceptions

- Use exceptions to handle errors you don't expect.
- If you catch an exception, it should be to:
  - Fix an expected problem.
  - Add context.
  - Otherwise, use a global handler.

### Testing

- Use the Jest testing framework with standard NestJS utilities (@nestjs/testing, supertest, etc.).
- Follow the Arrange-Act-Assert pattern in unit tests.
- Use the Given-When-Then pattern in acceptance tests and end-to-end (E2E) tests.
- Place all tests in a top-level tests/ folder, replicating the source structure:
  - Unit tests for controllers, services, and repositories go in tests/unit/
  - Integration tests go in tests/integration/
  - E2E tests for each API module go in tests/e2e/, structured by route/module name
- Name test files using the format: _.spec.ts for unit and integration, and _.e2e-spec.ts for E2E tests.
- Create unit tests for every public method in:
  - Controllers (api/controllers)
  - Services (infrastructure/services or feature services)
  - Repositories (mock database dependencies)
- Use test doubles (mocks, stubs, spies) to isolate dependencies.
  - Only mock internal or expensive external services.
  - Do not mock lightweight or deterministic utilities.
- Clearly name test variables:
  - inputX, mockX, actualX, expectedX, etc.
- Use describe blocks by method name or route group, and it blocks for each scenario.
- Add an admin/test smoke route to each controller to verify base connectivity.
- Favor isolated tests:
  - Prefer unit tests first.
  - Add integration tests for use-case-level logic.
  - Add E2E tests for HTTP requests through the app.
- Each module should include:
  - Unit tests for services and controller logic
  - Integration tests for repository and database behavior
  - E2E tests validating exposed HTTP routes

### Basic Principles

- Use modular architecture based on domain separation and clean architecture principles.
- Encapsulate each feature in its own module using the following structure:
  - Place NestJS modules in src/api/modules/ — one module per main domain (e.g., role.module.ts).
  - Place primary controllers for routes in src/api/controllers/, named after the domain (e.g., role.controller.ts).
  - Place DTOs (input types with class-validator) in src/infrastructure/dtos/.
  - Place entities in src/domain/entities/ — representing core domain models, pure and decoupled from frameworks.
  - Place enums used by entities or domain logic in src/domain/enums/.
  - Define migrations and seed logic in src/domain/migrations/.
  - Implement repository interfaces in src/infrastructure/repositories/interfaces/.
  - Implement repository logic in src/infrastructure/repositories/ using Prisma or the ORM of choice.
  - Place shared Prisma services in src/infrastructure/repositories/prisma.service.ts.
  - Place cross-cutting utility functions in src/shared/utils/.
  - Place shared constants in src/shared/constants/ using as const.
  - Place custom error/exception classes in src/shared/exceptions/.
  - Leave space for src/infrastructure/services/ to define services used across infrastructure (optional, domain-specific).
- Define one service per entity. Place business logic and orchestration in these services.
- Use Prisma for data persistence. Prisma schema file is in src/domain/migrations/schema.prisma.
- Use a global app.module.ts as the root and load domain modules there.
- Ensure a separation of concerns:
  - Controllers handle HTTP concerns and validation.
  - Services handle domain logic.
  - Repositories handle persistence logic.
- Prefer immutability and always type everything.
- Respect the SOLID principles and use dependency inversion (DI) for all services and repositories.
